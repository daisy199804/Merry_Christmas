<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Golden Noel Magic - Gesture 3D Tree</title>
    
    <!-- 1. 样式表 (全内置，解决路径问题) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body { margin: 0; background-color: #051005; color: white; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
      canvas { touch-action: none; outline: none; }
      #error-log { display: none; }
      
      /* 加载动画 */
      .loader-container {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        background: radial-gradient(circle at center, #1a2e1a 0%, #000000 100%);
        z-index: 100;
      }
      .tree-loader {
        width: 50px; height: 50px;
        border: 4px solid #FFD700;
        border-bottom-color: transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>

    <!-- 2. MediaPipe 依赖 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <!-- 3. Babel & Import Map -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "three": "https://esm.sh/three@0.160.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?deps=three@0.160.0,react@18.2.0,react-dom@18.2.0",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?deps=three@0.160.0,react@18.2.0,react-dom@18.2.0,@react-three/fiber@8.15.16",
    "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?deps=three@0.160.0,react@18.2.0,react-dom@18.2.0,@react-three/fiber@8.15.16",
    "maath/easing": "https://esm.sh/maath@0.10.7/easing?deps=three@0.160.0",
    "lucide-react": "https://esm.sh/lucide-react@0.292.0?deps=react@18.2.0",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "maath/": "https://esm.sh/maath@^0.10.8/"
  }
}
</script>
  </head>
  <body>
    <div id="root">
      <div class="loader-container">
        <div class="tree-loader"></div>
        <p class="mt-4 text-yellow-500 font-serif tracking-widest text-sm animate-pulse">CRAFTING GOLDEN MAGIC...</p>
      </div>
    </div>

    <div id="error-log" class="fixed top-0 left-0 w-full h-full bg-black/95 text-red-500 p-8 z-[200] font-mono text-xs overflow-auto"></div>

    <!-- 主逻辑脚本 -->
    <script type="text/babel" data-type="module">
      import React, { useState, useCallback, useRef, useMemo, useEffect } from 'react';
      import ReactDOM from 'react-dom/client';
      import { Canvas, useFrame, useThree } from '@react-three/fiber';
      import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';
      import { Environment, Image, Float } from '@react-three/drei';
      import * as THREE from 'three';
      import { damp3, damp } from 'maath/easing';
      import { Upload, Hand, Grip, ZoomIn, Trash2, Sparkles } from 'lucide-react';

      // --- 常量配置 ---
      const COLORS = {
        MATTE_GREEN: '#1B3022',
        BRIGHT_GREEN: '#2D5A27',
        METALLIC_GOLD: '#FFD700',
        SOFT_GOLD: '#E6BE8A',
        CHRISTMAS_RED: '#991B1B',
        WHITE: '#F8FAFC',
      };

      const CONFIG = {
        PARTICLE_COUNT: 1500,
        TREE_HEIGHT: 13,
        TREE_RADIUS_BOTTOM: 4.8,
        SCATTER_RADIUS: 16,
      };

      // --- 组件: 金色螺旋彩带 ---
      const Garland = ({ visible }) => {
        const curve = useMemo(() => {
          const points = [];
          const loops = 6;
          for (let t = 0; t <= 1; t += 0.005) {
            const y = CONFIG.TREE_HEIGHT * (t - 0.5);
            const r = (CONFIG.TREE_RADIUS_BOTTOM + 0.3) * (1 - t) + 0.2;
            const theta = t * Math.PI * 2 * loops;
            points.push(new THREE.Vector3(Math.cos(theta) * r, y, Math.sin(theta) * r));
          }
          return new THREE.CatmullRomCurve3(points);
        }, []);

        const ref = useRef();
        useFrame((state, delta) => {
          if (!ref.current) return;
          const targetScale = visible ? 1 : 0;
          damp3(ref.current.scale, [targetScale, targetScale, targetScale], 0.4, delta);
          ref.current.rotation.y += delta * 0.1;
        });

        return (
          <mesh ref={ref}>
            <tubeGeometry args={[curve, 160, 0.08, 8, false]} />
            <meshStandardMaterial color={COLORS.METALLIC_GOLD} metalness={1} roughness={0.1} emissive={COLORS.METALLIC_GOLD} emissiveIntensity={0.5} />
          </mesh>
        );
      };

      // --- 组件: 丰富多样的粒子 ---
      const Ornament = ({ data, appState }) => {
        const ref = useRef();
        useFrame((state, delta) => {
          if (!ref.current) return;
          const target = appState === 'TREE' ? data.posTree : data.posScatter;
          damp3(ref.current.position, target, 0.5 + Math.random() * 0.5, delta);
          ref.current.rotation.x += delta * (0.2 + Math.random());
          ref.current.rotation.y += delta * (0.2 + Math.random());
        });

        return (
          <mesh ref={ref} scale={data.scale}>
            {data.type === 'ring' && <torusGeometry args={[0.4, 0.15, 8, 16]} />}
            {data.type === 'diamond' && <octahedronGeometry args={[0.6, 0]} />}
            {data.type === 'sphere' && <sphereGeometry args={[0.5, 8, 8]} />}
            {data.type === 'cube' && <boxGeometry args={[0.7, 0.7, 0.7]} />}
            <meshStandardMaterial 
              color={data.color} 
              metalness={data.isGold ? 1 : 0.6} 
              roughness={data.isGold ? 0.1 : 0.4} 
              emissive={data.color} 
              emissiveIntensity={data.isGold ? 0.6 : 0.1} 
            />
          </mesh>
        );
      };

      // --- 组件: 树顶之星 ---
      const TreeStar = ({ appState }) => {
        const ref = useRef();
        useFrame((state, delta) => {
          if (!ref.current) return;
          const targetY = appState === 'TREE' ? CONFIG.TREE_HEIGHT / 2 + 0.8 : 12;
          damp3(ref.current.position, [0, targetY, 0], 0.8, delta);
          ref.current.rotation.y += delta * 2;
        });

        return (
          <group ref={ref}>
            <mesh>
              <octahedronGeometry args={[1, 0]} />
              <meshStandardMaterial color={COLORS.METALLIC_GOLD} emissive={COLORS.METALLIC_GOLD} emissiveIntensity={3} />
            </mesh>
            <pointLight color={COLORS.METALLIC_GOLD} intensity={3} distance={10} />
          </group>
        );
      };

      // --- 主场景组件 ---
      const Scene = ({ appState, photos, focusedIndex, handPos }) => {
        const groupRef = useRef();
        
        const data = useMemo(() => {
          const particles = [];
          const goldenAngle = Math.PI * (3 - Math.sqrt(5));
          
          for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
            const t = i / CONFIG.PARTICLE_COUNT;
            const yTree = CONFIG.TREE_HEIGHT * (t - 0.5);
            const rTree = CONFIG.TREE_RADIUS_BOTTOM * Math.pow(1 - (yTree + CONFIG.TREE_HEIGHT/2)/CONFIG.TREE_HEIGHT, 0.8) + 0.2;
            const theta = i * goldenAngle;
            
            const isSurface = Math.random() > 0.3;
            const rFinal = rTree * (isSurface ? (0.95 + Math.random() * 0.1) : Math.random() * 0.8);
            
            const rand = Math.random();
            let type = 'sphere';
            if (isSurface) {
              if (rand > 0.85) type = 'ring';
              else if (rand > 0.7) type = 'diamond';
              else if (rand > 0.4) type = 'sphere';
              else type = 'cube';
            }

            let color = COLORS.METALLIC_GOLD;
            const colorRand = Math.random();
            // 大幅增加金色比例 (约 60%)
            if (colorRand > 0.6) color = COLORS.METALLIC_GOLD;
            else if (colorRand > 0.4) color = COLORS.SOFT_GOLD;
            else if (colorRand > 0.2) color = COLORS.CHRISTMAS_RED;
            else color = COLORS.BRIGHT_GREEN;

            if (type === 'ring' || type === 'diamond') color = COLORS.METALLIC_GOLD;

            particles.push({
              id: i,
              type,
              isGold: color === COLORS.METALLIC_GOLD || color === COLORS.SOFT_GOLD,
              color,
              scale: Math.random() * 0.15 + 0.05,
              posTree: [Math.cos(theta) * rFinal, yTree, Math.sin(theta) * rFinal],
              posScatter: [(Math.random()-0.5)*30, (Math.random()-0.5)*30, (Math.random()-0.5)*30]
            });
          }
          return particles;
        }, []);

        useFrame((state, delta) => {
          if (appState === 'SCATTER') {
            damp3(state.camera.rotation, [handPos.current.y * 0.4, handPos.current.x * 0.4, 0], 0.5, delta);
          } else if (appState === 'TREE') {
            groupRef.current.rotation.y += delta * 0.15;
            damp3(state.camera.position, [0, 2, 20], 1, delta);
            damp3(state.camera.rotation, [0, 0, 0], 1, delta);
          } else {
            damp3(state.camera.position, [0, 0, 10], 1, delta);
          }
        });

        return (
          <>
            <Environment preset="forest" />
            <ambientLight intensity={0.5} />
            <pointLight position={[10, 10, 10]} intensity={2} color={COLORS.SOFT_GOLD} />
            <group ref={groupRef}>
              <Garland visible={appState === 'TREE'} />
              {data.map(p => <Ornament key={p.id} data={p} appState={appState} />)}
              {photos.map((url, i) => (
                <Photo key={i} url={url} index={i} appState={appState} isFocused={focusedIndex === i} />
              ))}
              <TreeStar appState={appState} />
            </group>
          </>
        );
      };

      const Photo = ({ url, index, appState, isFocused }) => {
        const ref = useRef();
        const posTree = useMemo(() => {
          const theta = (index / 10) * Math.PI * 4;
          const y = (index / 10 - 0.5) * CONFIG.TREE_HEIGHT;
          const r = (CONFIG.TREE_RADIUS_BOTTOM + 0.8) * (1 - (y + CONFIG.TREE_HEIGHT/2)/CONFIG.TREE_HEIGHT) + 0.5;
          return [Math.cos(theta) * r, y, Math.sin(theta) * r];
        }, [index]);

        const posScatter = useMemo(() => [(Math.random()-0.5)*15, (Math.random()-0.5)*15, (Math.random()-0.5)*10], []);

        useFrame((state, delta) => {
          if (!ref.current) return;
          let targetPos = appState === 'TREE' ? posTree : posScatter;
          let targetScale = 1;

          if (appState === 'FOCUS') {
            if (isFocused) { targetPos = [0, 0, 6]; targetScale = 3.5; }
            else { targetPos = [posScatter[0]*1.5, posScatter[1]*1.5, -10]; targetScale = 0.2; }
          }
          
          damp3(ref.current.position, targetPos, 0.5, delta);
          damp(ref.current.scale, 'x', targetScale, 0.5, delta);
          damp(ref.current.scale, 'y', targetScale, 0.5, delta);
          if (appState !== 'FOCUS') ref.current.lookAt(0, ref.current.position.y, 0);
          else if (isFocused) damp3(ref.current.rotation, [0,0,0], 0.5, delta);
        });

        return (
          <group ref={ref}>
            <Image url={url} scale={[1.5, 1.5]} transparent />
            <mesh position={[0,0,-0.02]}>
               <planeGeometry args={[1.6, 1.6]} />
               <meshStandardMaterial color={COLORS.METALLIC_GOLD} metalness={1} roughness={0.1} />
            </mesh>
          </group>
        );
      };

      // --- 手势识别管理器 ---
      const HandInput = ({ onGesture }) => {
        const videoRef = useRef();
        useEffect(() => {
          const hands = new window.Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
          });
          hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });
          hands.onResults((res) => {
            if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
              const lm = res.multiHandLandmarks[0];
              const x = (0.5 - lm[9].x) * 2;
              const y = (0.5 - lm[9].y) * 2;
              const isFingerOpen = (t, p) => lm[t].y < lm[p].y;
              const openCount = [8,12,16,20].filter(i => isFingerOpen(i, i-2)).length;
              const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
              
              let gesture = 'NONE';
              if (openCount === 0) gesture = 'FIST';
              else if (dist < 0.05) gesture = 'PINCH';
              else if (openCount >= 3) gesture = 'OPEN';
              onGesture(gesture, x, y);
            } else onGesture('NONE', 0, 0);
          });

          const camera = new window.Camera(videoRef.current, {
            onFrame: async () => { await hands.send({ image: videoRef.current }); },
            width: 640, height: 480
          });
          camera.start();
          return () => { camera.stop(); hands.close(); };
        }, []);

        return <video ref={videoRef} className="fixed bottom-4 right-4 w-40 h-30 rounded-lg border-2 border-yellow-600 opacity-60 pointer-events-none scale-x-[-1] z-50" playsInline muted />;
      };

      // --- 主应用 ---
      const App = () => {
        const [state, setState] = useState('TREE');
        const [gesture, setGesture] = useState('NONE');
        const [photos, setPhotos] = useState(['https://picsum.photos/400/600', 'https://picsum.photos/401/400', 'https://picsum.photos/402/400']);
        const [focusedIdx, setFocusedIdx] = useState(null);
        const handPos = useRef({ x: 0, y: 0 });
        const lastT = useRef(0);

        const onGesture = useCallback((g, x, y) => {
          setGesture(g);
          handPos.current = { x, y };
          const now = Date.now();
          if (now - lastT.current < 600) return;

          if (g === 'FIST' && state !== 'TREE') { setState('TREE'); lastT.current = now; }
          if (g === 'OPEN' && state !== 'SCATTER') { setState('SCATTER'); setFocusedIdx(null); lastT.current = now; }
          if (g === 'PINCH' && state === 'SCATTER') {
            setFocusedIdx(p => (p === null ? 0 : (p + 1) % photos.length));
            setState('FOCUS');
            lastT.current = now;
          }
        }, [state, photos.length]);

        return (
          <div className="w-full h-screen relative">
            <Canvas camera={{ position: [0, 2, 20], fov: 45 }}>
              <Scene appState={state} photos={photos} focusedIndex={focusedIdx} handPos={handPos} />
              <EffectComposer>
                <Bloom luminanceThreshold={0.4} intensity={1.2} />
                <Vignette darkness={0.7} />
              </EffectComposer>
            </Canvas>
            
            <HandInput onGesture={onGesture} />

            <!-- UI Overlay -->
            <div className="absolute inset-0 p-10 pointer-events-none flex flex-col justify-between z-40">
              <div className="flex justify-between items-start pointer-events-auto">
                <div>
                  <h1 className="text-5xl font-serif text-yellow-500 tracking-tighter italic">Golden <span className="text-white not-italic">Noel</span></h1>
                  <p className="text-xs tracking-[0.3em] text-yellow-500/50 mt-2">GESTURE INTERACTIVE EXPERIENCE</p>
                </div>
                <label className="bg-yellow-600/20 border border-yellow-500/50 px-6 py-3 rounded-full flex items-center gap-3 cursor-pointer hover:bg-yellow-600/40 transition">
                  <Upload size={16} className="text-yellow-500" />
                  <span className="text-xs font-bold tracking-widest">ADD MEMORY</span>
                  <input type="file" className="hidden" onChange={e => {
                    if (e.target.files[0]) setPhotos(p => [...p, URL.createObjectURL(e.target.files[0])]);
                  }} />
                </label>
              </div>

              <div className="flex justify-center gap-10 bg-black/40 backdrop-blur-xl p-6 rounded-3xl border border-white/10 pointer-events-auto">
                <div className={`flex flex-col items-center gap-2 ${gesture === 'FIST' ? 'text-yellow-400 scale-110' : 'text-white/40'} transition-all`}>
                  <Grip size={20} /><span className="text-[10px] font-bold">FIST: TREE</span>
                </div>
                <div className={`flex flex-col items-center gap-2 ${gesture === 'OPEN' ? 'text-yellow-400 scale-110' : 'text-white/40'} transition-all`}>
                  <Hand size={20} /><span className="text-[10px] font-bold">OPEN: SCATTER</span>
                </div>
                <div className={`flex flex-col items-center gap-2 ${gesture === 'PINCH' ? 'text-yellow-400 scale-110' : 'text-white/40'} transition-all`}>
                  <ZoomIn size={20} /><span className="text-[10px] font-bold">PINCH: FOCUS</span>
                </div>
              </div>
            </div>
          </div>
        );
      };

      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
  </body>
</html>